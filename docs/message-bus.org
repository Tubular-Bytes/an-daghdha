* Message bus planning

Topics are logical separation between messages, it uses the same broadcast channel, topic is encapsulated in the message, actors decide what they process.
This way actors can listen to topics by a wildcard and then use match statements to filter the selected tasks.

Message types depending on communication participants:

- Application -> All
  shutdown
- API -> Actors
  auth, task
- Ticker -> Actors
  tick

* Actor types

Authx - responsible for authorization and authentication - direct database access
Storage - responsible for distributing IO for the database - direct database access
Inventory - represents a single account, keeps track of assets - database access through Storage actor

** Authentication and authorization

- Authn: API receives an authn message, dispatches a task to the auth actor and waits for the answer or timeout.
  Task should include username, password and the reply channel.
- Authz: API receives any operations other than authn with an =Authorization= header, dispatches a task with the token for validation and waits for the answer or timeout.
  Task should include PASETO token and the reply channel.

** Storage

Inventory actors are responsible for persisting and caching data but these operations happen through the Storage actor. This actor listens for the usual CRUD operations and perform the tasks asynchronously. They emit two replies: one is instant, acknowledging the operation or returning possible validation errors, the other is sent via the reply channel if it's included in the task. This reply is optional for most operations except =read=: this operation requires the reply channel to send the requested value.

** Inventory

These actors manipulate the database via the storage layer to indicate state changes for assets they manage: resources, buildings, etc...

* Message types

** There would be two different kinds of messages and their response counterparts, depending on which layer boundaries they're crossing:

1. API messages: these messages are sent from the API layer to the broker, requesting a specific action to be performed. They are much simpler than the second kind as the client is agnostic to internals, they only need to know what action they want to perform and the necessary parameters.

2. Task messages: these messages are sent from the broker to the actors, requesting them to perform a specific action. These messages are more complex as they don't only include the action but the necessary context and data for the actor to execute the task.

API messages are always handled as request-response types: the broker has to reply once the task has been sent for processing, then possibly again when the task is complete.

Task messages can be fire and forget, they can just indicate a task has to be done but their result is not important for the caller. Possible issues and errors will be logged and wired to trigger alerts so operators can take action if needed.

Different message types are wrapped inside a Message enum for versatility and ease of use. The embedded types can take whatever form it requires to convey values over the bus.

*** API messages



** shutdown
#+begin_src
struct Shutdown {}
#+end_src

** authentication
#+begin_src
struct Authentication {
        username: String,
        password: String,
        reply: tokio::sync::oneshot::Sender<AuthenticationResponse>
}
#+end_src

** authorization
#+begin_src
struct Authorization {
        token: String,
        reply: tokio::sync::oneshot::Sender<AuthorizationResponse>
}
#+end_src

** tick
#+begin_src
struct Tick {}
#+end_src

** task
Tasks will be a special kind of structure because it will contain an embedded type as tasks can be different kinds with different attributes.

#+begin_src
enum Task {
        Build(inventory_id, blueprint_id),
        Train(inventory_id, formula_id),
        Produce(inventory_id, recipe_id),
}
#+end_src
